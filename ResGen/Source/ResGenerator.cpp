#include "ResGenerator.h"
#include "Print.h"

#include <fstream>
#include <string>

using namespace resgen;

constexpr static char HEADER[] =
"// Copyright (c) 2024-2025 Kynex7510\n"
"// Use of this source code is governed by the Boost Software License 1.0 that can be found in the LICENSE file.\n"
"// This file has been automatically generated by ResGen. DO NOT EDIT!";

constexpr static char HASH_CODE[] =
"fnv_init: .word 0x811c9dc5\n"
"fnv_prime: .word 0x01000193\n\n"
"// uint32_t fnv(const char* sym);\n"
".type fnv, %function\n"
"fnv:\n"
"    ldr r1, =fnv_init\n"
"    ldr r1, [r1]\n"
"    ldr r2, =fnv_prime\n\n"
"    ldr r2, [r2]\n\n"
"    _fnv_loop:\n"
"    ldrb r3, [r0]\n"
"    cmp r3, #0\n"
"    beq _fnv_end\n\n"
"    eor r1, r3\n"
"    mul r1, r2\n"
"    add r0, #1\n"
"    b _fnv_loop\n\n"
"    _fnv_end:\n"
"    mov r0, r1\n"
"    bx lr";

constexpr static char RESOLVER_CODE[] =
"    push {r4, r5}\n"
"    mov r5, r0\n"
"    bl fnv\n\n"
"    ldr r1, =num_buckets\n"
"    ldr r1, [r1]\n"
"    bl __aeabi_uidivmod\n\n"
"    lsl r1, #2\n"
"    ldr r0, =buckets\n"
"    add r0, r1\n"
"    ldr r4, [r0]\n\n"
"    _resolver_loop:\n"
"    ldr r3, [r4, #4]\n"
"    cmp r3, #0\n"
"    beq _resolver_end\n"
"    ldr r2, [r4]\n"
"    ldr r0, =names\n"
"    add r0, r2\n"
"    mov r1, r5\n"
"    bl strcmp\n"
"    cmp r0, #0\n"
"    beq _resolver_end\n"
"    add r4, #8\n"
"    b _resolver_loop\n\n"
"    _resolver_end:\n"
"    ldr r0, [r4, #4]\n"
"    pop {r4, r5}\n"
"    bx lr";

ResGenerator::ResGenerator(SymTable&& symTable, std::string_view resolverName) : m_SymTable(std::move(symTable)) {
    m_ResolverName = resolverName;
}

bool ResGenerator::writeToFile(const std::filesystem::path& path) {
    std::ofstream f(path);
    if (!f.is_open()) {
        resgen::printError({}, "could not write to \"{}\"", path.string());
        return false;
    }

    f << HEADER << "\n\n";
    f << ".arm\n\n";
    f << ".global " << m_ResolverName << "\n\n";
    f << ".section .text\n";
    f << ".align 2\n\n";
    f << HASH_CODE << "\n\n";

    f << "num_buckets: .word " << m_SymTable.buckets().size() << "\n\n";
    f << "// void* " << m_ResolverName << "(const char* sym);\n";
    f << ".type " << m_ResolverName << ", %function\n";
    f << m_ResolverName << ":\n";
    f << RESOLVER_CODE << "\n\n";

    f << ".section .rodata, \"a\", %progbits\n";
    f << ".align 2\n\n";
    f << "buckets:\n";

    size_t index = 0;
    for (const auto& bucket : m_SymTable.buckets()) {
        f << ".word entries+" << index << '\n';
        index += (bucket.size() + 1) * 8;
    }

    f << "\nentries:\n";

    for (const auto& bucket : m_SymTable.buckets()) {
        for (const auto& entry : bucket) {
            f << ".word " << entry << '\n';
            f << ".word " << m_SymTable.mapped(entry) << '\n';
        }

        f << ".word 0\n";
        f << ".word 0\n";
    }

    f << "\nnames:\n";

    const auto& buffer = m_SymTable.stringTable();
    index = 0;
    while (index < buffer.size()) {
        const auto p = reinterpret_cast<const char*>(buffer.data() + index);
        f << ".asciz \"" << p << "\"\n";
        index += strlen(p) + 1;
    }

    return true;
}